// backend/services/antiExploitationLeaveService.js
const LeaveRequest = require('../models/LeaveRequest');
const Holiday = require('../models/Holiday');
const { logAction } = require('./auditLogger');

/**
 * Anti-Exploitation Leave Validation Service
 * Implements STRICT company leave policies:
 * - Monthly leave frequency cap: Maximum 4 requests per month (PENDING + APPROVED)
 * - Maximum working leave days: 5 working days per month
 * - Friday restriction: No leaves on Friday (all types)
 * - Monday restriction: No leaves on Monday (all types)
 * - Friday-Monday clubbing prevention: No leaves adjacent to Friday or Monday
 */

class AntiExploitationLeaveService {
    /**
     * Check if a Saturday is a company OFF day based on alternate Saturday policy
     * @param {Date} date - The date to check (should be a Saturday)
     * @param {string} saturdayPolicy - The Saturday policy from employee
     * @returns {boolean} True if it's an OFF Saturday
     */
    static isOffSaturday(date, saturdayPolicy) {
        if (date.getDay() !== 6) return false; // Not a Saturday
        
        const weekNum = Math.ceil(date.getDate() / 7);
        
        switch (saturdayPolicy) {
            case 'All Saturdays Off':
                return true;
            case 'All Saturdays Working':
                return false;
            case 'Week 1 & 3 Off':
                return (weekNum === 1 || weekNum === 3);
            case 'Week 2 & 4 Off':
                return (weekNum === 2 || weekNum === 4);
            default:
                return false;
        }
    }

    /**
     * Check if a date is a holiday
     * @param {Date} date - The date to check
     * @param {Array} holidays - Array of holiday objects
     * @returns {boolean} True if it's a holiday
     */
    static isHoliday(date, holidays) {
        if (!holidays || holidays.length === 0) return false;
        
        const dateStr = date.toISOString().split('T')[0];
        return holidays.some(holiday => {
            // Skip tentative holidays (no date or isTentative flag)
            if (!holiday.date || holiday.isTentative) {
                return false;
            }
            const holidayDate = new Date(holiday.date);
            if (isNaN(holidayDate.getTime())) {
                return false;
            }
            const holidayDateStr = holidayDate.toISOString().split('T')[0];
            return holidayDateStr === dateStr;
        });
    }

    /**
     * Check if a date is Sunday
     * @param {Date} date - The date to check
     * @returns {boolean} True if it's Sunday
     */
    static isSunday(date) {
        return date.getDay() === 0;
    }

    /**
     * Check if a date is Friday
     * @param {Date} date - The date to check
     * @returns {boolean} True if it's Friday
     */
    static isFriday(date) {
        return date.getDay() === 5;
    }

    /**
     * Check if a date is Monday
     * @param {Date} date - The date to check
     * @returns {boolean} True if it's Monday
     */
    static isMonday(date) {
        return date.getDay() === 1;
    }

    /**
     * Get the next day from a given date
     * @param {Date} date - The date
     * @returns {Date} Next day
     */
    static getNextDay(date) {
        const nextDay = new Date(date);
        nextDay.setDate(nextDay.getDate() + 1);
        return nextDay;
    }

    /**
     * Get the previous day from a given date
     * @param {Date} date - The date
     * @returns {Date} Previous day
     */
    static getPreviousDay(date) {
        const previousDay = new Date(date);
        previousDay.setDate(previousDay.getDate() - 1);
        return previousDay;
    }

    /**
     * Count working days in leave dates (excludes weekends and holidays)
     * @param {Array} leaveDates - Array of leave dates
     * @param {Object} employee - Employee object
     * @param {Array} holidays - Array of holiday objects
     * @returns {number} Number of working days
     */
    static countWorkingDaysInLeaveDates(leaveDates, employee, holidays) {
        if (!leaveDates || leaveDates.length === 0) return 0;
        
        const saturdayPolicy = employee.alternateSaturdayPolicy || 'All Saturdays Working';
        let workingDaysCount = 0;
        
        for (const leaveDate of leaveDates) {
            const date = new Date(leaveDate);
            date.setHours(0, 0, 0, 0);
            const dayOfWeek = date.getDay();
            
            // Skip Sundays (always off)
            if (this.isSunday(date)) {
                continue;
            }
            
            // Skip Saturdays based on policy
            if (dayOfWeek === 6) {
                if (this.isOffSaturday(date, saturdayPolicy)) {
                    continue;
                }
            }
            
            // Skip holidays
            if (this.isHoliday(date, holidays)) {
                continue;
            }
            
            // It's a working day
            workingDaysCount++;
        }
        
        return workingDaysCount;
    }

    /**
     * Rule 1: Friday-Monday Restriction
     * Block ALL leaves on Friday or Monday
     * Applies to ALL leave types (no exceptions)
     */
    static checkFridayMondayRestriction(leaveDates, employee, holidays, requestType) {
        const errors = [];
        const warnings = [];
        
        for (const leaveDate of leaveDates) {
            const date = new Date(leaveDate);
            date.setHours(0, 0, 0, 0);
            
            if (this.isFriday(date)) {
                errors.push('As per company policy, leaves cannot be applied on Friday.');
                return { blocked: true, errors, warnings, rule: 'FRIDAY_RESTRICTION' };
            }
            
            if (this.isMonday(date)) {
                errors.push('As per company policy, leaves cannot be applied on Monday.');
                return { blocked: true, errors, warnings, rule: 'MONDAY_RESTRICTION' };
            }
        }
        
        return { blocked: false, errors: [], warnings: [], rule: null };
    }

    /**
     * Rule 2: Friday-Monday Clubbing Prevention
     * Block leaves adjacent to Friday or Monday (prevents artificial long breaks)
     * - Block leaves on Thursday (adjacent to Friday)
     * - Block leaves on Tuesday (adjacent to Monday)
     * Applies to ALL leave types (no exceptions)
     */
    static checkFridayMondayClubbing(leaveDates, employee, holidays, requestType) {
        const errors = [];
        const warnings = [];
        
        for (const leaveDate of leaveDates) {
            const date = new Date(leaveDate);
            date.setHours(0, 0, 0, 0);
            const dayOfWeek = date.getDay();
            
            // Block Thursday (day 4) - adjacent to Friday
            if (dayOfWeek === 4) {
                errors.push('As per company policy, leaves cannot be applied on Thursday (adjacent to Friday).');
                return { blocked: true, errors, warnings, rule: 'FRIDAY_MONDAY_CLUBBING' };
            }
            
            // Block Tuesday (day 2) - adjacent to Monday
            if (dayOfWeek === 2) {
                errors.push('As per company policy, leaves cannot be applied on Tuesday (adjacent to Monday).');
                return { blocked: true, errors, warnings, rule: 'FRIDAY_MONDAY_CLUBBING' };
            }
        }
        
        return { blocked: false, errors: [], warnings: [], rule: null };
    }

    /**
     * Rule 3: Monthly Leave Frequency Cap
     * Count distinct leave applications (PENDING + APPROVED) in the calendar month
     * Maximum 4 applications per month (PENDING + APPROVED)
     * REJECTED/Cancelled leaves do NOT count toward the limit
     * Applies to ALL leave types (Planned, Casual, Sick, Loss of Pay, etc.)
     */
    static async checkMonthlyLeaveFrequency(employeeId, leaveDates) {
        const errors = [];
        const warnings = [];
        
        // Get the month and year from the first leave date
        const firstLeaveDate = new Date(leaveDates[0]);
        firstLeaveDate.setHours(0, 0, 0, 0);
        const month = firstLeaveDate.getMonth(); // 0-11
        const year = firstLeaveDate.getFullYear();
        
        // Calculate month start and end
        const monthStart = new Date(year, month, 1);
        const monthEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
        
        // Count PENDING + APPROVED leave applications that have leave dates in this month
        // REJECTED/Cancelled leaves do NOT count toward the limit
        // This counts applications by the month of leave dates, not creation month
        // Leave type does NOT matter - all types count toward the limit
        const activeLeaves = await LeaveRequest.find({
            employee: employeeId,
            status: { $in: ['Pending', 'Approved'] }, // Count PENDING + APPROVED
            leaveDates: {
                $elemMatch: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            }
        });
        
        const activeLeaveCount = activeLeaves.length;
        const maxRequestsPerMonth = 4;
        
        if (activeLeaveCount >= maxRequestsPerMonth) {
            errors.push(`You have already submitted ${activeLeaveCount} leave request(s) this month (pending or approved). Maximum ${maxRequestsPerMonth} requests are allowed per month.`);
            return { blocked: true, errors, warnings, rule: 'MONTHLY_FREQUENCY_CAP', count: activeLeaveCount };
        }
        
        return { blocked: false, errors, warnings, rule: null, count: activeLeaveCount };
    }

    /**
     * Rule 4: Maximum Working Leave Days per Month
     * Maximum 5 working days on leave per month
     * Counts only working days (excludes weekends and holidays)
     * Applies to ALL leave types (Planned, Casual, Sick, Loss of Pay, etc.)
     */
    static async checkMaximumWorkingLeaveDays(employee, leaveDates, holidays, leaveType) {
        const errors = [];
        const warnings = [];
        
        // Get the month and year from the first leave date
        const firstLeaveDate = new Date(leaveDates[0]);
        firstLeaveDate.setHours(0, 0, 0, 0);
        const month = firstLeaveDate.getMonth();
        const year = firstLeaveDate.getFullYear();
        
        // Calculate month start and end
        const monthStart = new Date(year, month, 1);
        const monthEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
        
        // Get all holidays in this month
        const monthHolidays = await Holiday.find({
            date: {
                $gte: monthStart,
                $lte: monthEnd
            }
        });
        
        // Get all APPROVED leaves in this month
        const approvedLeaves = await LeaveRequest.find({
            employee: employee._id,
            status: 'Approved',
            leaveDates: {
                $elemMatch: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            }
        });
        
        // Count working days from approved leaves
        let totalApprovedWorkingLeaveDays = 0;
        approvedLeaves.forEach(leave => {
            const leaveDatesInMonth = leave.leaveDates.filter(leaveDate => {
                const leaveDateObj = new Date(leaveDate);
                leaveDateObj.setHours(0, 0, 0, 0);
                return leaveDateObj >= monthStart && leaveDateObj <= monthEnd;
            });
            
            const workingDays = this.countWorkingDaysInLeaveDates(leaveDatesInMonth, employee, monthHolidays);
            const dayMultiplier = leave.leaveType === 'Full Day' ? 1 : 0.5;
            totalApprovedWorkingLeaveDays += (workingDays * dayMultiplier);
        });
        
        // Count working days from current requested leave
        const leaveDatesInMonth = leaveDates.filter(leaveDate => {
            const leaveDateObj = new Date(leaveDate);
            leaveDateObj.setHours(0, 0, 0, 0);
            return leaveDateObj >= monthStart && leaveDateObj <= monthEnd;
        });
        
        const requestedWorkingDays = this.countWorkingDaysInLeaveDates(leaveDatesInMonth, employee, monthHolidays);
        const dayMultiplier = leaveType === 'Full Day' ? 1 : 0.5;
        const currentRequestWorkingDays = requestedWorkingDays * dayMultiplier;
        
        const totalWorkingLeaveDays = totalApprovedWorkingLeaveDays + currentRequestWorkingDays;
        const maxWorkingLeaveDaysPerMonth = 5;
        
        if (totalWorkingLeaveDays > maxWorkingLeaveDaysPerMonth) {
            errors.push(`You have already taken ${totalApprovedWorkingLeaveDays.toFixed(1)} working day(s) of leave this month. Maximum ${maxWorkingLeaveDaysPerMonth} working days are allowed per month.`);
            return { 
                blocked: true, 
                errors, 
                warnings, 
                rule: 'MAXIMUM_WORKING_LEAVE_DAYS',
                totalWorkingLeaveDays: totalWorkingLeaveDays.toFixed(1),
                maxWorkingLeaveDays: maxWorkingLeaveDaysPerMonth
            };
        }
        
        return { 
            blocked: false, 
            errors, 
            warnings, 
            rule: null,
            totalWorkingLeaveDays: totalWorkingLeaveDays.toFixed(1),
            maxWorkingLeaveDays: maxWorkingLeaveDaysPerMonth
        };
    }

    /**
     * Main anti-exploitation validation function
     * Runs all validation rules in the correct order
     * @param {Object} employee - Employee object
     * @param {Array} leaveDates - Array of leave dates
     * @param {Array} holidays - Array of holiday objects (optional)
     * @param {String} requestType - Leave request type (Planned, Casual, Sick, Loss of Pay, etc.)
     * @param {String} leaveType - Leave type (Full Day, Half Day - First Half, Half Day - Second Half)
     */
    static async validateAntiExploitation(employee, leaveDates, holidays = null, requestType = null, leaveType = 'Full Day') {
        const allErrors = [];
        const allWarnings = [];
        const blockedRules = [];
        const validationDetails = {};
        
        // Fetch holidays if not provided
        if (!holidays) {
            const firstLeaveDate = new Date(leaveDates[0]);
            const month = firstLeaveDate.getMonth();
            const year = firstLeaveDate.getFullYear();
            const monthStart = new Date(year, month, 1);
            const monthEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
            
            holidays = await Holiday.find({
                date: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            });
        }
        
        // Rule 1: Monthly frequency cap (PENDING + APPROVED)
        const frequencyCheck = await this.checkMonthlyLeaveFrequency(employee._id, leaveDates);
        if (frequencyCheck.blocked) {
            allErrors.push(...frequencyCheck.errors);
            blockedRules.push(frequencyCheck.rule);
            validationDetails.monthlyFrequency = {
                blocked: true,
                rule: frequencyCheck.rule,
                count: frequencyCheck.count
            };
        } else {
            validationDetails.monthlyFrequency = {
                blocked: false,
                count: frequencyCheck.count
            };
        }
        allWarnings.push(...frequencyCheck.warnings);
        
        // Rule 2: Maximum working leave days (5 working days per month)
        const workingDaysCheck = await this.checkMaximumWorkingLeaveDays(employee, leaveDates, holidays, leaveType);
        if (workingDaysCheck.blocked) {
            allErrors.push(...workingDaysCheck.errors);
            blockedRules.push(workingDaysCheck.rule);
            validationDetails.maximumWorkingLeaveDays = {
                blocked: true,
                rule: workingDaysCheck.rule,
                totalWorkingLeaveDays: workingDaysCheck.totalWorkingLeaveDays,
                maxWorkingLeaveDays: workingDaysCheck.maxWorkingLeaveDays
            };
        } else {
            validationDetails.maximumWorkingLeaveDays = {
                blocked: false,
                totalWorkingLeaveDays: workingDaysCheck.totalWorkingLeaveDays,
                maxWorkingLeaveDays: workingDaysCheck.maxWorkingLeaveDays
            };
        }
        allWarnings.push(...workingDaysCheck.warnings);
        
        // Rule 3: Friday-Monday restriction (no leaves on Friday or Monday)
        const fridayMondayRestrictionCheck = this.checkFridayMondayRestriction(leaveDates, employee, holidays, requestType);
        if (fridayMondayRestrictionCheck.blocked) {
            allErrors.push(...fridayMondayRestrictionCheck.errors);
            blockedRules.push(fridayMondayRestrictionCheck.rule);
            validationDetails.fridayMondayRestriction = {
                blocked: true,
                rule: fridayMondayRestrictionCheck.rule
            };
        }
        
        // Rule 4: Friday-Monday clubbing prevention
        const clubbingCheck = this.checkFridayMondayClubbing(leaveDates, employee, holidays, requestType);
        if (clubbingCheck.blocked) {
            allErrors.push(...clubbingCheck.errors);
            blockedRules.push(clubbingCheck.rule);
            validationDetails.fridayMondayClubbing = {
                blocked: true,
                rule: clubbingCheck.rule
            };
        }
        
        const isBlocked = blockedRules.length > 0;
        
        // Log blocked leave attempts
        if (isBlocked) {
            await this.logBlockedLeave(employee, leaveDates, blockedRules, validationDetails, requestType, frequencyCheck.count);
        }
        
        return {
            blocked: isBlocked,
            errors: allErrors,
            warnings: allWarnings,
            blockedRules,
            validationDetails
        };
    }

    /**
     * Log blocked leave attempts for audit
     * @param {Object} employee - Employee object
     * @param {Array} leaveDates - Array of leave dates
     * @param {Array} blockedRules - Array of rules that blocked the leave
     * @param {Object} validationDetails - Validation details object
     * @param {String} requestType - Leave request type
     * @param {Number} approvedLeaveCount - Number of approved leaves at apply time
     */
    static async logBlockedLeave(employee, leaveDates, blockedRules, validationDetails, requestType = null, approvedLeaveCount = null) {
        try {
            const firstLeaveDate = new Date(leaveDates[0]);
            const month = firstLeaveDate.getMonth() + 1;
            const year = firstLeaveDate.getFullYear();
            
            // Determine which rule triggered the block
            const policyRuleTriggered = blockedRules.length > 0 ? blockedRules[0] : null;
            
            await logAction({
                action: 'LEAVE_BLOCKED_ANTI_EXPLOITATION',
                userId: employee._id.toString(),
                details: {
                    employeeCode: employee.employeeCode,
                    employeeName: employee.fullName,
                    leaveType: requestType || 'Unknown',
                    month: month,
                    year: year,
                    leaveDates: leaveDates.map(d => new Date(d).toISOString().split('T')[0]),
                    blockedRules: blockedRules,
                    policyRuleTriggered: policyRuleTriggered,
                    approvedLeaveCountAtApplyTime: approvedLeaveCount,
                    validationDetails: validationDetails,
                    timestamp: new Date().toISOString()
                }
            });
        } catch (error) {
            console.error('Error logging blocked leave:', error);
        }
    }
}

module.exports = AntiExploitationLeaveService;

