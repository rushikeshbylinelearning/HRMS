// backend/services/antiExploitationLeaveService.js
const LeaveRequest = require('../models/LeaveRequest');
const Holiday = require('../models/Holiday');
const { logAction } = require('./auditLogger');

/**
 * Anti-Exploitation Leave Validation Service
 * Implements STRICT company leave policies:
 * - Monthly leave frequency cap: Maximum 4 requests per month (PENDING + APPROVED)
 * - Maximum working leave days: 5 working days per month
 * - Friday restriction: No leaves on Friday (all types)
 * - Monday restriction: No leaves on Monday (all types)
 * - Friday-Monday clubbing prevention: No leaves adjacent to Friday or Monday
 */

class AntiExploitationLeaveService {
    /**
     * Check if a Saturday is a company OFF day based on alternate Saturday policy
     * @param {Date} date - The date to check (should be a Saturday)
     * @param {string} saturdayPolicy - The Saturday policy from employee
     * @returns {boolean} True if it's an OFF Saturday
     */
    static isOffSaturday(date, saturdayPolicy) {
        if (date.getDay() !== 6) return false; // Not a Saturday
        
        const weekNum = Math.ceil(date.getDate() / 7);
        
        switch (saturdayPolicy) {
            case 'All Saturdays Off':
                return true;
            case 'All Saturdays Working':
                return false;
            case 'Week 1 & 3 Off':
                return (weekNum === 1 || weekNum === 3);
            case 'Week 2 & 4 Off':
                return (weekNum === 2 || weekNum === 4);
            default:
                return false;
        }
    }

    /**
     * Check if a date is a holiday
     * @param {Date} date - The date to check
     * @param {Array} holidays - Array of holiday objects
     * @returns {boolean} True if it's a holiday
     */
    static isHoliday(date, holidays) {
        if (!holidays || holidays.length === 0) return false;
        
        const dateStr = date.toISOString().split('T')[0];
        return holidays.some(holiday => {
            // Skip tentative holidays (no date or isTentative flag)
            if (!holiday.date || holiday.isTentative) {
                return false;
            }
            const holidayDate = new Date(holiday.date);
            if (isNaN(holidayDate.getTime())) {
                return false;
            }
            const holidayDateStr = holidayDate.toISOString().split('T')[0];
            return holidayDateStr === dateStr;
        });
    }

    /**
     * Check if a date is Sunday
     * @param {Date} date - The date to check
     * @returns {boolean} True if it's Sunday
     */
    static isSunday(date) {
        return date.getDay() === 0;
    }

    /**
     * Check if a date is Friday
     * @param {Date} date - The date to check
     * @returns {boolean} True if it's Friday
     */
    static isFriday(date) {
        return date.getDay() === 5;
    }

    /**
     * Check if a date is Monday
     * @param {Date} date - The date to check
     * @returns {boolean} True if it's Monday
     */
    static isMonday(date) {
        return date.getDay() === 1;
    }

    /**
     * Get the next day from a given date
     * @param {Date} date - The date
     * @returns {Date} Next day
     */
    static getNextDay(date) {
        const nextDay = new Date(date);
        nextDay.setDate(nextDay.getDate() + 1);
        return nextDay;
    }

    /**
     * Get the previous day from a given date
     * @param {Date} date - The date
     * @returns {Date} Previous day
     */
    static getPreviousDay(date) {
        const previousDay = new Date(date);
        previousDay.setDate(previousDay.getDate() - 1);
        return previousDay;
    }

    /**
     * Count working days in leave dates (excludes weekends and holidays)
     * @param {Array} leaveDates - Array of leave dates
     * @param {Object} employee - Employee object
     * @param {Array} holidays - Array of holiday objects
     * @returns {number} Number of working days
     */
    static countWorkingDaysInLeaveDates(leaveDates, employee, holidays) {
        if (!leaveDates || leaveDates.length === 0) return 0;
        
        const saturdayPolicy = employee.alternateSaturdayPolicy || 'All Saturdays Working';
        let workingDaysCount = 0;
        
        for (const leaveDate of leaveDates) {
            const date = new Date(leaveDate);
            date.setHours(0, 0, 0, 0);
            const dayOfWeek = date.getDay();
            
            // Skip Sundays (always off)
            if (this.isSunday(date)) {
                continue;
            }
            
            // Skip Saturdays based on policy
            if (dayOfWeek === 6) {
                if (this.isOffSaturday(date, saturdayPolicy)) {
                    continue;
                }
            }
            
            // Skip holidays
            if (this.isHoliday(date, holidays)) {
                continue;
            }
            
            // It's a working day
            workingDaysCount++;
        }
        
        return workingDaysCount;
    }

    /**
     * Rule 1: Intelligent Friday-Monday Restriction
     * Block Friday ONLY when immediately before scheduled Saturday OFF
     * Block Monday ONLY when it creates a long weekend bridge
     * Allow Tuesday→Friday when Saturday is working
     * Allow Casual/LOP ≥10 days in advance regardless of weekdays
     * Allow Planned Leave with valid advance notice regardless of weekdays
     */
    static checkFridayMondayRestriction(leaveDates, employee, holidays, requestType) {
        const errors = [];
        const warnings = [];
        
        // Check advance notice for override using IST-safe date parsing
        const { parseISTDate, getISTDateString } = require('../utils/istTime');
        const today = parseISTDate(getISTDateString());
        const firstLeaveDate = parseISTDate(leaveDates[0]);
        const daysDiff = Math.floor((firstLeaveDate - today) / (1000 * 60 * 60 * 24));
        
        // INTELLIGENT PLANNED LEAVE: Allow with valid advance notice
        if (requestType === 'Planned') {
            const workingDaysCount = this.countWorkingDaysInLeaveDates(leaveDates, employee, holidays);
            const requiredDays = workingDaysCount > 7 ? 60 : 30;
            
            if (daysDiff >= requiredDays) {
                return { blocked: false, errors: [], warnings: [], rule: null };
            }
        }
        
        // CRITICAL FIX: Allow Casual >10 days in advance regardless of weekdays
        if (requestType === 'Casual' && daysDiff > 10) {
            return { blocked: false, errors: [], warnings: [], rule: null };
        }
        
        // CRITICAL FIX: Allow LOP anytime regardless of weekdays or advance notice
        if (requestType === 'Loss of Pay') {
            return { blocked: false, errors: [], warnings: [], rule: null };
        }
        
        // CRITICAL FIX: Allow Comp-Off anytime (they have their own separate validation rules)
        if (requestType === 'Compensatory') {
            return { blocked: false, errors: [], warnings: [], rule: null };
        }
        
        for (const leaveDate of leaveDates) {
            const date = parseISTDate(leaveDate);
            const dayOfWeek = date.getDay();
            
            // Intelligent Friday logic
            if (dayOfWeek === 5) { // Friday
                const nextDay = new Date(date);
                nextDay.setDate(nextDay.getDate() + 1);
                
                // Block only if Saturday is scheduled OFF
                if (this.isOffSaturday(nextDay, employee.alternateSaturdayPolicy || 'All Saturdays Working')) {
                    const dateStr = date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
                    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    errors.push(`Leave cannot be applied on ${dayNames[dayOfWeek]}, ${dateStr} because the following Saturday is scheduled off, creating a long weekend. Apply at least 10 days in advance for more flexibility.`);
                    return { blocked: true, errors, warnings, rule: 'FRIDAY_BEFORE_SATURDAY_OFF' };
                }
                // Allow Friday when Saturday is working
            }
            
            // Intelligent Monday logic  
            if (dayOfWeek === 1) { // Monday
                const prevDay = new Date(date);
                prevDay.setDate(prevDay.getDate() - 1);
                
                // Check if it creates a bridge after Sunday
                if (prevDay.getDay() === 0) { // Previous day is Sunday
                    // Check if there's a pattern that creates artificial long weekend
                    // For now, allow Monday unless policy conditions are met
                    // TODO: Implement more sophisticated bridging detection based on company calendar
                }
            }
        }
        
        return { blocked: false, errors: [], warnings: [], rule: null };
    }

    /**
     * Rule 2: Weekday Blocking (Updated Logic)
     * Block Tuesday and Thursday globally (as per new policy)
     * Remove old Friday-Monday clubbing prevention
     * Allow Planned Leave with valid advance notice regardless of weekdays
     */
    static checkWeekdayBlocking(leaveDates, employee, holidays, requestType) {
        const errors = [];
        const warnings = [];
        
        // Check advance notice for override using IST-safe date parsing
        const { parseISTDate, getISTDateString } = require('../utils/istTime');
        const today = parseISTDate(getISTDateString());
        const firstLeaveDate = parseISTDate(leaveDates[0]);
        const daysDiff = Math.floor((firstLeaveDate - today) / (1000 * 60 * 60 * 24));
        
        // INTELLIGENT PLANNED LEAVE: Allow with valid advance notice
        if (requestType === 'Planned') {
            const workingDaysCount = this.countWorkingDaysInLeaveDates(leaveDates, employee, holidays);
            const requiredDays = workingDaysCount > 7 ? 60 : 30;
            
            if (daysDiff >= requiredDays) {
                return { blocked: false, errors: [], warnings: [], rule: null };
            }
        }
        
        // CRITICAL FIX: Allow Casual >10 days in advance regardless of weekdays
        if (requestType === 'Casual' && daysDiff > 10) {
            return { blocked: false, errors: [], warnings: [], rule: null };
        }
        
        // CRITICAL FIX: Allow LOP anytime regardless of weekdays or advance notice
        if (requestType === 'Loss of Pay') {
            return { blocked: false, errors: [], warnings: [], rule: null };
        }
        
        // CRITICAL FIX: Allow Comp-Off anytime (they have their own separate validation rules)
        if (requestType === 'Compensatory') {
            return { blocked: false, errors: [], warnings: [], rule: null };
        }
        
        for (const leaveDate of leaveDates) {
            const date = parseISTDate(leaveDate);
            const dayOfWeek = date.getDay();
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayName = dayNames[dayOfWeek];
            
            // Block Tuesday (day 2) for short-notice requests
            if (dayOfWeek === 2) {
                errors.push(`Leave cannot be applied on ${dayName} when requested within 10 days. For more flexibility, apply leave at least 10 days in advance.`);
                return { blocked: true, errors, warnings, rule: 'TUESDAY_BLOCKED' };
            }
            
            // Block Thursday (day 4) for short-notice requests
            if (dayOfWeek === 4) {
                errors.push(`Leave cannot be applied on ${dayName} when requested within 10 days. For more flexibility, apply leave at least 10 days in advance.`);
                return { blocked: true, errors, warnings, rule: 'THURSDAY_BLOCKED' };
            }
        }
        
        return { blocked: false, errors: [], warnings: [], rule: null };
    }

    /**
     * Rule 3: Monthly Leave Frequency Cap
     * Count distinct leave applications (PENDING + APPROVED) in the calendar month
     * Maximum 4 applications per month (PENDING + APPROVED)
     * REJECTED/Cancelled leaves do NOT count toward the limit
     * Applies to ALL leave types (Planned, Casual, Sick, Loss of Pay, etc.)
     */
    static async checkMonthlyLeaveFrequency(employeeId, leaveDates) {
        const errors = [];
        const warnings = [];
        
        // Get the month and year from the first leave date
        const firstLeaveDate = new Date(leaveDates[0]);
        firstLeaveDate.setHours(0, 0, 0, 0);
        const month = firstLeaveDate.getMonth(); // 0-11
        const year = firstLeaveDate.getFullYear();
        
        // Get month name for user-friendly messaging
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                           'July', 'August', 'September', 'October', 'November', 'December'];
        const monthName = monthNames[month];
        
        // Calculate month start and end
        const monthStart = new Date(year, month, 1);
        const monthEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
        
        // Count PENDING + APPROVED leave applications that have leave dates in this month
        // REJECTED/Cancelled leaves do NOT count toward the limit
        // This counts applications by the month of leave dates, not creation month
        // Leave type does NOT matter - all types count toward the limit
        const activeLeaves = await LeaveRequest.find({
            employee: employeeId,
            status: { $in: ['Pending', 'Approved'] }, // Count PENDING + APPROVED
            leaveDates: {
                $elemMatch: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            }
        });
        
        const activeLeaveCount = activeLeaves.length;
        const maxRequestsPerMonth = 4;
        
        if (activeLeaveCount >= maxRequestsPerMonth) {
            errors.push(`You have already submitted ${activeLeaveCount} leave request${activeLeaveCount !== 1 ? 's' : ''} for ${monthName} ${year}. The maximum allowed is ${maxRequestsPerMonth} requests per month.`);
            return { blocked: true, errors, warnings, rule: 'MONTHLY_FREQUENCY_CAP', count: activeLeaveCount };
        }
        
        return { blocked: false, errors, warnings, rule: null, count: activeLeaveCount };
    }

    /**
     * Rule 4: Maximum Working Leave Days per Month (Intelligent)
     * Maximum 5 working days on leave per month
     * Counts only working days (excludes weekends and holidays)
     * PLANNED LEAVE IS EXEMPT from this cap
     */
    static async checkMaximumWorkingLeaveDays(employee, leaveDates, holidays, leaveType, requestType) {
        const errors = [];
        const warnings = [];
        
        // INTELLIGENT PLANNED LEAVE: Exempt from working days cap
        if (requestType === 'Planned') {
            return { 
                blocked: false, 
                errors, 
                warnings, 
                rule: null,
                totalWorkingLeaveDays: '0 (Planned Leave exempt)',
                maxWorkingLeaveDays: 5
            };
        }
        
        // CRITICAL FIX: LOP LEAVE: Exempt from working days cap
        if (requestType === 'Loss of Pay') {
            return { 
                blocked: false, 
                errors, 
                warnings, 
                rule: null,
                totalWorkingLeaveDays: '0 (LOP Leave exempt)',
                maxWorkingLeaveDays: 5
            };
        }
        
        // Get the month and year from the first leave date
        const firstLeaveDate = new Date(leaveDates[0]);
        firstLeaveDate.setHours(0, 0, 0, 0);
        const month = firstLeaveDate.getMonth();
        const year = firstLeaveDate.getFullYear();
        
        // Calculate month start and end
        const monthStart = new Date(year, month, 1);
        const monthEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
        
        // Get all holidays in this month
        const monthHolidays = await Holiday.find({
            date: {
                $gte: monthStart,
                $lte: monthEnd
            }
        });
        
        // Get all APPROVED leaves in this month (excluding Planned Leave)
        const approvedLeaves = await LeaveRequest.find({
            employee: employee._id,
            status: 'Approved',
            requestType: { $ne: 'Planned' }, // Exclude Planned Leave from count
            leaveDates: {
                $elemMatch: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            }
        });
        
        // Count working days from approved leaves (excluding Planned Leave)
        let totalApprovedWorkingLeaveDays = 0;
        approvedLeaves.forEach(leave => {
            const leaveDatesInMonth = leave.leaveDates.filter(leaveDate => {
                const leaveDateObj = new Date(leaveDate);
                leaveDateObj.setHours(0, 0, 0, 0);
                return leaveDateObj >= monthStart && leaveDateObj <= monthEnd;
            });
            
            const workingDays = this.countWorkingDaysInLeaveDates(leaveDatesInMonth, employee, monthHolidays);
            const dayMultiplier = leave.leaveType === 'Full Day' ? 1 : 0.5;
            totalApprovedWorkingLeaveDays += (workingDays * dayMultiplier);
        });
        
        // Count working days from current requested leave
        const leaveDatesInMonth = leaveDates.filter(leaveDate => {
            const leaveDateObj = new Date(leaveDate);
            leaveDateObj.setHours(0, 0, 0, 0);
            return leaveDateObj >= monthStart && leaveDateObj <= monthEnd;
        });
        
        const requestedWorkingDays = this.countWorkingDaysInLeaveDates(leaveDatesInMonth, employee, monthHolidays);
        const dayMultiplier = leaveType === 'Full Day' ? 1 : 0.5;
        const currentRequestWorkingDays = requestedWorkingDays * dayMultiplier;
        
        const totalWorkingLeaveDays = totalApprovedWorkingLeaveDays + currentRequestWorkingDays;
        const maxWorkingLeaveDaysPerMonth = 5;
        
        if (totalWorkingLeaveDays > maxWorkingLeaveDaysPerMonth) {
            const alreadyUsed = totalApprovedWorkingLeaveDays;
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                               'July', 'August', 'September', 'October', 'November', 'December'];
            const monthName = monthNames[month];
            
            errors.push(`You have already used ${alreadyUsed.toFixed(1)} working day${alreadyUsed !== 1 ? 's' : ''} of leave in ${monthName} ${year}. This request would exceed the monthly limit of ${maxWorkingLeaveDaysPerMonth} working days.`);
            return { 
                blocked: true, 
                errors, 
                warnings, 
                rule: 'MAXIMUM_WORKING_LEAVE_DAYS',
                totalWorkingLeaveDays: totalWorkingLeaveDays.toFixed(1),
                maxWorkingLeaveDays: maxWorkingLeaveDaysPerMonth
            };
        }
        
        return { 
            blocked: false, 
            errors, 
            warnings, 
            rule: null,
            totalWorkingLeaveDays: totalWorkingLeaveDays.toFixed(1),
            maxWorkingLeaveDays: maxWorkingLeaveDaysPerMonth
        };
    }

    /**
     * Main anti-exploitation validation function
     * Runs all validation rules in the correct order
     * @param {Object} employee - Employee object
     * @param {Array} leaveDates - Array of leave dates
     * @param {Array} holidays - Array of holiday objects (optional)
     * @param {String} requestType - Leave request type (Planned, Casual, Sick, Loss of Pay, etc.)
     * @param {String} leaveType - Leave type (Full Day, Half Day - First Half, Half Day - Second Half)
     */
    static async validateAntiExploitation(employee, leaveDates, holidays = null, requestType = null, leaveType = 'Full Day') {
        const allErrors = [];
        const allWarnings = [];
        const blockedRules = [];
        const validationDetails = {};
        
        // Fetch holidays if not provided
        if (!holidays) {
            const firstLeaveDate = new Date(leaveDates[0]);
            const month = firstLeaveDate.getMonth();
            const year = firstLeaveDate.getFullYear();
            const monthStart = new Date(year, month, 1);
            const monthEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
            
            holidays = await Holiday.find({
                date: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            });
        }
        
        // Rule 1: Monthly frequency cap (PENDING + APPROVED)
        const frequencyCheck = await this.checkMonthlyLeaveFrequency(employee._id, leaveDates);
        if (frequencyCheck.blocked) {
            allErrors.push(...frequencyCheck.errors);
            blockedRules.push(frequencyCheck.rule);
            validationDetails.monthlyFrequency = {
                blocked: true,
                rule: frequencyCheck.rule,
                count: frequencyCheck.count
            };
        } else {
            validationDetails.monthlyFrequency = {
                blocked: false,
                count: frequencyCheck.count
            };
        }
        allWarnings.push(...frequencyCheck.warnings);
        
        // Rule 2: Maximum working leave days (5 working days per month, Planned Leave exempt)
        const workingDaysCheck = await this.checkMaximumWorkingLeaveDays(employee, leaveDates, holidays, leaveType, requestType);
        if (workingDaysCheck.blocked) {
            allErrors.push(...workingDaysCheck.errors);
            blockedRules.push(workingDaysCheck.rule);
            validationDetails.maximumWorkingLeaveDays = {
                blocked: true,
                rule: workingDaysCheck.rule,
                totalWorkingLeaveDays: workingDaysCheck.totalWorkingLeaveDays,
                maxWorkingLeaveDays: workingDaysCheck.maxWorkingLeaveDays
            };
        } else {
            validationDetails.maximumWorkingLeaveDays = {
                blocked: false,
                totalWorkingLeaveDays: workingDaysCheck.totalWorkingLeaveDays,
                maxWorkingLeaveDays: workingDaysCheck.maxWorkingLeaveDays
            };
        }
        allWarnings.push(...workingDaysCheck.warnings);
        
        // Rule 3: Intelligent Friday-Monday restriction
        const fridayMondayRestrictionCheck = this.checkFridayMondayRestriction(leaveDates, employee, holidays, requestType);
        if (fridayMondayRestrictionCheck.blocked) {
            allErrors.push(...fridayMondayRestrictionCheck.errors);
            blockedRules.push(fridayMondayRestrictionCheck.rule);
            validationDetails.fridayMondayRestriction = {
                blocked: true,
                rule: fridayMondayRestrictionCheck.rule
            };
        }
        
        // Rule 4: Weekday blocking (Tuesday/Thursday)
        const weekdayBlockingCheck = this.checkWeekdayBlocking(leaveDates, employee, holidays, requestType);
        if (weekdayBlockingCheck.blocked) {
            allErrors.push(...weekdayBlockingCheck.errors);
            blockedRules.push(weekdayBlockingCheck.rule);
            validationDetails.weekdayBlocking = {
                blocked: true,
                rule: weekdayBlockingCheck.rule
            };
        }
        
        const isBlocked = blockedRules.length > 0;
        
        // Log blocked leave attempts
        if (isBlocked) {
            await this.logBlockedLeave(employee, leaveDates, blockedRules, validationDetails, requestType, frequencyCheck.count);
        }
        
        return {
            blocked: isBlocked,
            errors: allErrors,
            warnings: allWarnings,
            blockedRules,
            validationDetails
        };
    }

    /**
     * Log blocked leave attempts for audit
     * @param {Object} employee - Employee object
     * @param {Array} leaveDates - Array of leave dates
     * @param {Array} blockedRules - Array of rules that blocked the leave
     * @param {Object} validationDetails - Validation details object
     * @param {String} requestType - Leave request type
     * @param {Number} approvedLeaveCount - Number of approved leaves at apply time
     */
    static async logBlockedLeave(employee, leaveDates, blockedRules, validationDetails, requestType = null, approvedLeaveCount = null) {
        try {
            const firstLeaveDate = new Date(leaveDates[0]);
            const month = firstLeaveDate.getMonth() + 1;
            const year = firstLeaveDate.getFullYear();
            
            // Determine which rule triggered the block
            const policyRuleTriggered = blockedRules.length > 0 ? blockedRules[0] : null;
            
            await logAction({
                action: 'LEAVE_BLOCKED_ANTI_EXPLOITATION',
                userId: employee._id.toString(),
                details: {
                    employeeCode: employee.employeeCode,
                    employeeName: employee.fullName,
                    leaveType: requestType || 'Unknown',
                    month: month,
                    year: year,
                    leaveDates: leaveDates.map(d => new Date(d).toISOString().split('T')[0]),
                    blockedRules: blockedRules,
                    policyRuleTriggered: policyRuleTriggered,
                    approvedLeaveCountAtApplyTime: approvedLeaveCount,
                    validationDetails: validationDetails,
                    timestamp: new Date().toISOString()
                }
            });
        } catch (error) {
            console.error('Error logging blocked leave:', error);
        }
    }
}

module.exports = AntiExploitationLeaveService;

