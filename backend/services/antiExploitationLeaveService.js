// backend/services/antiExploitationLeaveService.js
const LeaveRequest = require('../models/LeaveRequest');
const Holiday = require('../models/Holiday');
const { logAction } = require('./auditLogger');

/**
 * Anti-Exploitation Leave Validation Service
 * Implements company productivity safeguards:
 * - Friday-Saturday-Sunday clubbing prevention
 * - Monthly leave frequency cap (3 applications per month)
 * - Working days dilution protection (30% threshold)
 * - Smart warning system (2 applications, 20% threshold)
 */

class AntiExploitationLeaveService {
    /**
     * Check if a Saturday is a company OFF day based on alternate Saturday policy
     * @param {Date} date - The date to check (should be a Saturday)
     * @param {string} saturdayPolicy - The Saturday policy from employee
     * @returns {boolean} True if it's an OFF Saturday
     */
    static isOffSaturday(date, saturdayPolicy) {
        if (date.getDay() !== 6) return false; // Not a Saturday
        
        const weekNum = Math.ceil(date.getDate() / 7);
        
        switch (saturdayPolicy) {
            case 'All Saturdays Off':
                return true;
            case 'All Saturdays Working':
                return false;
            case 'Week 1 & 3 Off':
                return (weekNum === 1 || weekNum === 3);
            case 'Week 2 & 4 Off':
                return (weekNum === 2 || weekNum === 4);
            default:
                return false;
        }
    }

    /**
     * Check if a date is a holiday
     * @param {Date} date - The date to check
     * @param {Array} holidays - Array of holiday objects
     * @returns {boolean} True if it's a holiday
     */
    static isHoliday(date, holidays) {
        if (!holidays || holidays.length === 0) return false;
        
        const dateStr = date.toISOString().split('T')[0];
        return holidays.some(holiday => {
            // Skip tentative holidays (no date or isTentative flag)
            if (!holiday.date || holiday.isTentative) {
                return false;
            }
            const holidayDate = new Date(holiday.date);
            if (isNaN(holidayDate.getTime())) {
                return false;
            }
            const holidayDateStr = holidayDate.toISOString().split('T')[0];
            return holidayDateStr === dateStr;
        });
    }

    /**
     * Check if a date is Sunday
     * @param {Date} date - The date to check
     * @returns {boolean} True if it's Sunday
     */
    static isSunday(date) {
        return date.getDay() === 0;
    }

    /**
     * Check if a date is Friday
     * @param {Date} date - The date to check
     * @returns {boolean} True if it's Friday
     */
    static isFriday(date) {
        return date.getDay() === 5;
    }

    /**
     * Get the next day from a given date
     * @param {Date} date - The date
     * @returns {Date} Next day
     */
    static getNextDay(date) {
        const nextDay = new Date(date);
        nextDay.setDate(nextDay.getDate() + 1);
        return nextDay;
    }

    /**
     * Rule 1: Friday-Saturday-Sunday Clubbing Guard
     * Block leave if Friday is requested and next day is company OFF Saturday
     * EXCEPTION: Planned Leave is exempt from this restriction
     */
    static checkFridaySaturdayClubbing(leaveDates, employee, holidays, requestType) {
        const errors = [];
        const warnings = [];
        
        // Planned Leave is exempt from Friday-Saturday restriction
        if (requestType === 'Planned') {
            return { blocked: false, errors: [], warnings: [], rule: null };
        }
        
        for (const leaveDate of leaveDates) {
            const date = new Date(leaveDate);
            date.setHours(0, 0, 0, 0);
            
            if (this.isFriday(date)) {
                const nextDay = this.getNextDay(date);
                const saturdayPolicy = employee.alternateSaturdayPolicy || 'All Saturdays Working';
                
                // Check if next day is an OFF Saturday
                if (this.isOffSaturday(nextDay, saturdayPolicy)) {
                    errors.push('As per company policy, Friday leave before an off Saturday is not permitted for this leave type.');
                    return { blocked: true, errors, warnings, rule: 'FRIDAY_SATURDAY_CLUBBING' };
                }
            }
        }
        
        return { blocked: false, errors: [], warnings: [], rule: null };
    }

    /**
     * Rule 2: Monthly Leave Frequency Cap
     * Count distinct APPROVED leave applications in the calendar month (not days)
     * Maximum 3 APPROVED applications per month
     * Pending/Rejected/Cancelled leaves do NOT count toward the limit
     */
    static async checkMonthlyLeaveFrequency(employeeId, leaveDates) {
        const errors = [];
        const warnings = [];
        
        // Get the month and year from the first leave date
        const firstLeaveDate = new Date(leaveDates[0]);
        firstLeaveDate.setHours(0, 0, 0, 0);
        const month = firstLeaveDate.getMonth(); // 0-11
        const year = firstLeaveDate.getFullYear();
        
        // Calculate month start and end
        const monthStart = new Date(year, month, 1);
        const monthEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
        
        // Count only APPROVED leave applications that have leave dates in this month
        // Pending/Rejected/Cancelled leaves do NOT count toward the limit
        // This counts applications by the month of leave dates, not creation month
        const approvedLeaves = await LeaveRequest.find({
            employee: employeeId,
            status: 'Approved', // Only count APPROVED leaves
            leaveDates: {
                $elemMatch: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            }
        });
        
        const approvedLeaveCount = approvedLeaves.length;
        const maxApprovedPerMonth = 3;
        
        if (approvedLeaveCount >= maxApprovedPerMonth) {
            errors.push('You already have 3 approved leave requests this month. You are not eligible to apply for additional leave.');
            return { blocked: true, errors, warnings, rule: 'MONTHLY_FREQUENCY_CAP', count: approvedLeaveCount };
        }
        
        // Warning at 2 approved applications
        if (approvedLeaveCount >= 2) {
            warnings.push('You are approaching the monthly leave eligibility limit.');
        }
        
        return { blocked: false, errors, warnings, rule: null, count: approvedLeaveCount };
    }

    /**
     * Rule 3: Working Days Dilution Protection
     * Prevent scenario where non-working + leave days â‰¥ 30% of month
     * Calculate: (TotalLeaveDays + WeekendsCoveredByLeavePattern) / TotalWorkingDaysInMonth
     */
    static async checkWorkingDaysDilution(employee, leaveDates, holidays) {
        const errors = [];
        const warnings = [];
        
        // Get the month and year from the first leave date
        const firstLeaveDate = new Date(leaveDates[0]);
        firstLeaveDate.setHours(0, 0, 0, 0);
        const month = firstLeaveDate.getMonth();
        const year = firstLeaveDate.getFullYear();
        
        // Calculate month start and end
        const monthStart = new Date(year, month, 1);
        const monthEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
        
        // Get all holidays in this month
        const monthHolidays = await Holiday.find({
            date: {
                $gte: monthStart,
                $lte: monthEnd
            }
        });
        
        // Calculate total working days in the month
        let totalWorkingDays = 0;
        let totalSundays = 0;
        let totalOffSaturdays = 0;
        let totalHolidays = 0;
        
        const saturdayPolicy = employee.alternateSaturdayPolicy || 'All Saturdays Working';
        
        for (let d = new Date(monthStart); d <= monthEnd; d.setDate(d.getDate() + 1)) {
            const currentDate = new Date(d);
            const dayOfWeek = currentDate.getDay();
            
            // Skip Sundays (always off)
            if (this.isSunday(currentDate)) {
                totalSundays++;
                continue;
            }
            
            // Check Saturdays
            if (dayOfWeek === 6) {
                if (this.isOffSaturday(currentDate, saturdayPolicy)) {
                    totalOffSaturdays++;
                    continue;
                }
            }
            
            // Check holidays
            if (this.isHoliday(currentDate, monthHolidays)) {
                totalHolidays++;
                continue;
            }
            
            // It's a working day
            totalWorkingDays++;
        }
        
        // Get all approved leaves in this month
        const approvedLeaves = await LeaveRequest.find({
            employee: employee._id,
            status: 'Approved',
            leaveDates: {
                $elemMatch: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            }
        });
        
        // Calculate total leave days in this month (from approved leaves)
        let totalApprovedLeaveDays = 0;
        approvedLeaves.forEach(leave => {
            leave.leaveDates.forEach(leaveDate => {
                const leaveDateObj = new Date(leaveDate);
                leaveDateObj.setHours(0, 0, 0, 0);
                if (leaveDateObj >= monthStart && leaveDateObj <= monthEnd) {
                    const dayMultiplier = leave.leaveType === 'Full Day' ? 1 : 0.5;
                    totalApprovedLeaveDays += dayMultiplier;
                }
            });
        });
        
        // Add the current requested leave days
        // Calculate leave duration considering half days
        let currentRequestLeaveDays = 0;
        for (const leaveDate of leaveDates) {
            const leaveDateObj = new Date(leaveDate);
            leaveDateObj.setHours(0, 0, 0, 0);
            if (leaveDateObj >= monthStart && leaveDateObj <= monthEnd) {
                // For now, assume full day - this should be passed as parameter
                // But for anti-exploitation, we count each date as 1 day
                currentRequestLeaveDays += 1;
            }
        }
        
        const totalLeaveDays = totalApprovedLeaveDays + currentRequestLeaveDays;
        
        // Calculate dilution ratio
        // Formula: (TotalLeaveDays + TotalNonWorkingDays) / TotalDaysInMonth
        // This prevents excessive non-working days in a month
        const totalNonWorkingDays = totalSundays + totalOffSaturdays + totalHolidays;
        const totalDaysInMonth = totalWorkingDays + totalNonWorkingDays;
        const dilutionRatio = (totalLeaveDays + totalNonWorkingDays) / totalDaysInMonth;
        
        const threshold = 0.30; // 30%
        const warningThreshold = 0.20; // 20%
        
        if (dilutionRatio >= threshold) {
            errors.push('You are not eligible for further leave this month due to productivity policy limits.');
            return { 
                blocked: true, 
                errors, 
                warnings, 
                rule: 'WORKING_DAYS_DILUTION',
                ratio: dilutionRatio,
                totalLeaveDays,
                totalWorkingDays: totalDaysInMonth
            };
        }
        
        // Warning at 20%
        if (dilutionRatio >= warningThreshold) {
            warnings.push('You are approaching the monthly leave eligibility limit.');
        }
        
        return { 
            blocked: false, 
            errors, 
            warnings, 
            rule: null,
            ratio: dilutionRatio,
            totalLeaveDays,
            totalWorkingDays: totalDaysInMonth
        };
    }

    /**
     * Main anti-exploitation validation function
     * Runs all three rules and returns consolidated result
     * @param {Object} employee - Employee object
     * @param {Array} leaveDates - Array of leave dates
     * @param {Array} holidays - Array of holiday objects (optional)
     * @param {String} requestType - Leave request type (Planned, Casual, Sick, Loss of Pay, etc.)
     */
    static async validateAntiExploitation(employee, leaveDates, holidays = null, requestType = null) {
        const allErrors = [];
        const allWarnings = [];
        const blockedRules = [];
        const validationDetails = {};
        
        // Rule 1: Friday-Saturday clubbing (leave-type aware)
        const fridaySaturdayCheck = this.checkFridaySaturdayClubbing(leaveDates, employee, holidays, requestType);
        if (fridaySaturdayCheck.blocked) {
            allErrors.push(...fridaySaturdayCheck.errors);
            blockedRules.push(fridaySaturdayCheck.rule);
            validationDetails.fridaySaturdayClubbing = {
                blocked: true,
                rule: fridaySaturdayCheck.rule
            };
        }
        
        // Rule 2: Monthly frequency cap (approval-based)
        const frequencyCheck = await this.checkMonthlyLeaveFrequency(employee._id, leaveDates);
        if (frequencyCheck.blocked) {
            allErrors.push(...frequencyCheck.errors);
            blockedRules.push(frequencyCheck.rule);
            validationDetails.monthlyFrequency = {
                blocked: true,
                rule: frequencyCheck.rule,
                count: frequencyCheck.count
            };
        } else {
            validationDetails.monthlyFrequency = {
                blocked: false,
                count: frequencyCheck.count
            };
        }
        allWarnings.push(...frequencyCheck.warnings);
        
        // Rule 3: Working days dilution
        const dilutionCheck = await this.checkWorkingDaysDilution(employee, leaveDates, holidays);
        if (dilutionCheck.blocked) {
            allErrors.push(...dilutionCheck.errors);
            blockedRules.push(dilutionCheck.rule);
            validationDetails.workingDaysDilution = {
                blocked: true,
                rule: dilutionCheck.rule,
                ratio: dilutionCheck.ratio,
                totalLeaveDays: dilutionCheck.totalLeaveDays,
                totalWorkingDays: dilutionCheck.totalWorkingDays
            };
        } else {
            validationDetails.workingDaysDilution = {
                blocked: false,
                ratio: dilutionCheck.ratio,
                totalLeaveDays: dilutionCheck.totalLeaveDays,
                totalWorkingDays: dilutionCheck.totalWorkingDays
            };
        }
        allWarnings.push(...dilutionCheck.warnings);
        
        const isBlocked = blockedRules.length > 0;
        
        // Log blocked leave attempts
        if (isBlocked) {
            await this.logBlockedLeave(employee, leaveDates, blockedRules, validationDetails, requestType, frequencyCheck.count);
        }
        
        return {
            blocked: isBlocked,
            errors: allErrors,
            warnings: allWarnings,
            blockedRules,
            validationDetails
        };
    }

    /**
     * Log blocked leave attempts for audit
     * @param {Object} employee - Employee object
     * @param {Array} leaveDates - Array of leave dates
     * @param {Array} blockedRules - Array of rules that blocked the leave
     * @param {Object} validationDetails - Validation details object
     * @param {String} requestType - Leave request type
     * @param {Number} approvedLeaveCount - Number of approved leaves at apply time
     */
    static async logBlockedLeave(employee, leaveDates, blockedRules, validationDetails, requestType = null, approvedLeaveCount = null) {
        try {
            const firstLeaveDate = new Date(leaveDates[0]);
            const month = firstLeaveDate.getMonth() + 1;
            const year = firstLeaveDate.getFullYear();
            
            // Determine which rule triggered the block
            const policyRuleTriggered = blockedRules.length > 0 ? blockedRules[0] : null;
            
            await logAction({
                action: 'LEAVE_BLOCKED_ANTI_EXPLOITATION',
                userId: employee._id.toString(),
                details: {
                    employeeCode: employee.employeeCode,
                    employeeName: employee.fullName,
                    leaveType: requestType || 'Unknown',
                    month: month,
                    year: year,
                    leaveDates: leaveDates.map(d => new Date(d).toISOString().split('T')[0]),
                    blockedRules: blockedRules,
                    policyRuleTriggered: policyRuleTriggered,
                    approvedLeaveCountAtApplyTime: approvedLeaveCount,
                    validationDetails: validationDetails,
                    timestamp: new Date().toISOString()
                }
            });
        } catch (error) {
            console.error('Error logging blocked leave:', error);
        }
    }
}

module.exports = AntiExploitationLeaveService;

