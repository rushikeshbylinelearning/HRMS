// backend/services/antiExploitationLeaveService.js
const LeaveRequest = require('../models/LeaveRequest');
const Holiday = require('../models/Holiday');
const { logAction } = require('./auditLogger');
const { parseISTDate, getTodayIST, formatDateIST, getDatePartsIST, isDateBetweenIST } = require('../utils/dateUtils');

/**
 * Anti-Exploitation Leave Validation Service
 * Implements company productivity safeguards (IST-ONLY):
 * - Friday/Monday blocking (strict anti-clubbing policy)
 * - Monthly leave frequency cap (4 applications per month - PENDING + APPROVED)
 * - Monthly working days limit (5 working days max per month)
 * - All calculations in IST timezone only
 */

class AntiExploitationLeaveService {
    /**
     * Check if a Saturday is a company OFF day based on alternate Saturday policy (IST-aware)
     * @param {Date} date - The date to check (must be IST-parsed)
     * @param {string} saturdayPolicy - The Saturday policy from employee
     * @returns {boolean} True if it's an OFF Saturday
     */
    static isOffSaturday(date, saturdayPolicy) {
        // Get day-of-week using IST date parts
        const parts = getDatePartsIST(date);
        if (!parts) return false;
        
        const istDate = parseISTDate(`${parts.year}-${String(parts.month).padStart(2, '0')}-${String(parts.day).padStart(2, '0')}`);
        if (!istDate || istDate.getDay() !== 6) return false; // Not a Saturday
        
        // Calculate week number in month (IST-aware)
        const weekNum = Math.ceil(parts.day / 7);
        
        switch (saturdayPolicy) {
            case 'All Saturdays Off':
                return true;
            case 'All Saturdays Working':
                return false;
            case 'Week 1 & 3 Off':
                return (weekNum === 1 || weekNum === 3);
            case 'Week 2 & 4 Off':
                return (weekNum === 2 || weekNum === 4);
            default:
                return false;
        }
    }

    /**
     * Check if a date is a holiday (IST-aware)
     * @param {Date} date - The date to check (must be IST-parsed)
     * @param {Array} holidays - Array of holiday objects
     * @returns {boolean} True if it's a holiday
     */
    static isHoliday(date, holidays) {
        if (!holidays || holidays.length === 0) return false;
        
        // Use IST formatting for consistent comparison
        const dateStr = formatDateIST(date);
        if (!dateStr) return false;
        
        return holidays.some(holiday => {
            // Skip tentative holidays (no date or isTentative flag)
            if (!holiday.date || holiday.isTentative) {
                return false;
            }
            const holidayDate = parseISTDate(holiday.date);
            if (!holidayDate) {
                return false;
            }
            const holidayDateStr = formatDateIST(holidayDate);
            return holidayDateStr === dateStr;
        });
    }

    /**
     * Check if a date is Sunday (IST-aware)
     * @param {Date} date - The date to check (must be IST-parsed)
     * @returns {boolean} True if it's Sunday
     */
    static isSunday(date) {
        // Use IST date parts to ensure correct day-of-week
        const parts = getDatePartsIST(date);
        if (!parts) return false;
        // Create date from IST parts to get correct day-of-week
        const istDate = parseISTDate(`${parts.year}-${String(parts.month).padStart(2, '0')}-${String(parts.day).padStart(2, '0')}`);
        return istDate.getDay() === 0;
    }

    /**
     * Check if a date is Friday (IST-aware)
     * @param {Date} date - The date to check (must be IST-parsed)
     * @returns {boolean} True if it's Friday
     */
    static isFriday(date) {
        const parts = getDatePartsIST(date);
        if (!parts) return false;
        const istDate = parseISTDate(`${parts.year}-${String(parts.month).padStart(2, '0')}-${String(parts.day).padStart(2, '0')}`);
        return istDate.getDay() === 5;
    }

    /**
     * Check if a date is Monday (IST-aware)
     * @param {Date} date - The date to check (must be IST-parsed)
     * @returns {boolean} True if it's Monday
     */
    static isMonday(date) {
        const parts = getDatePartsIST(date);
        if (!parts) return false;
        const istDate = parseISTDate(`${parts.year}-${String(parts.month).padStart(2, '0')}-${String(parts.day).padStart(2, '0')}`);
        return istDate.getDay() === 1;
    }

    /**
     * Get the next day from a given date
     * @param {Date} date - The date
     * @returns {Date} Next day
     */
    static getNextDay(date) {
        const nextDay = new Date(date);
        nextDay.setDate(nextDay.getDate() + 1);
        return nextDay;
    }

    /**
     * Rule 1: Friday/Monday Blocking (STRICT Anti-Clubbing Policy)
     * Block leave if ANY requested date is Friday or Monday
     * Applies to ALL leave types (no exceptions)
     * This prevents clubbing leaves around weekends
     */
    static checkFridayMondayBlocking(leaveDates) {
        const errors = [];
        const warnings = [];
        
        // Parse all dates as IST
        const istDates = leaveDates.map(d => parseISTDate(d)).filter(d => d !== null);
        
        for (const date of istDates) {
            if (this.isFriday(date)) {
                errors.push('As per company policy, leave cannot be applied on Friday. This prevents leave clubbing around weekends.');
                return { blocked: true, errors, warnings, rule: 'FRIDAY_BLOCKING' };
            }
            
            if (this.isMonday(date)) {
                errors.push('As per company policy, leave cannot be applied on Monday. This prevents leave clubbing around weekends.');
                return { blocked: true, errors, warnings, rule: 'MONDAY_BLOCKING' };
            }
        }
        
        return { blocked: false, errors: [], warnings: [], rule: null };
    }

    /**
     * Rule 2: Monthly Leave Frequency Cap (IST-ONLY)
     * Count distinct PENDING + APPROVED leave applications in the calendar month
     * Maximum 4 active applications per month (PENDING + APPROVED together)
     * REJECTED/Cancelled leaves do NOT count
     */
    static async checkMonthlyLeaveFrequency(employeeId, leaveDates) {
        const errors = [];
        const warnings = [];
        
        // Parse first leave date as IST
        const firstLeaveDate = parseISTDate(leaveDates[0]);
        if (!firstLeaveDate) {
            errors.push('Invalid leave date provided.');
            return { blocked: true, errors, warnings, rule: 'INVALID_DATE' };
        }
        
        // Get month and year in IST
        const parts = getDatePartsIST(firstLeaveDate);
        if (!parts) {
            errors.push('Unable to determine month for leave date.');
            return { blocked: true, errors, warnings, rule: 'INVALID_DATE' };
        }
        
        const year = parts.year;
        const month = parts.month; // 1-12
        
        // Calculate month start and end in IST
        const monthStartStr = `${year}-${String(month).padStart(2, '0')}-01`;
        const monthStart = parseISTDate(monthStartStr);
        
        // Get last day of month
        const lastDay = new Date(year, month, 0).getDate(); // month is 1-12, this gets last day
        const monthEndStr = `${year}-${String(month).padStart(2, '0')}-${String(lastDay).padStart(2, '0')}`;
        const monthEnd = parseISTDate(monthEndStr);
        if (monthEnd) {
            monthEnd.setHours(23, 59, 59, 999);
        }
        
        if (!monthStart || !monthEnd) {
            errors.push('Unable to calculate month boundaries.');
            return { blocked: true, errors, warnings, rule: 'INVALID_DATE' };
        }
        
        // Count PENDING + APPROVED leave applications (NOT just APPROVED)
        // This prevents employees from submitting unlimited PENDING requests
        const activeLeaves = await LeaveRequest.find({
            employee: employeeId,
            status: { $in: ['Pending', 'Approved'] }, // Count PENDING + APPROVED
            leaveDates: {
                $elemMatch: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            }
        });
        
        const activeLeaveCount = activeLeaves.length;
        const maxActivePerMonth = 4; // Changed from 3 to 4, and includes PENDING
        
        if (activeLeaveCount >= maxActivePerMonth) {
            errors.push(`You already have ${activeLeaveCount} active leave request(s) this month (maximum ${maxActivePerMonth} allowed). Please wait for existing requests to be processed before submitting new ones.`);
            return { blocked: true, errors, warnings, rule: 'MONTHLY_FREQUENCY_CAP', count: activeLeaveCount };
        }
        
        // Warning at 3 active applications
        if (activeLeaveCount >= 3) {
            warnings.push(`You have ${activeLeaveCount} active leave request(s) this month. Only ${maxActivePerMonth - activeLeaveCount} more allowed.`);
        }
        
        return { blocked: false, errors, warnings, rule: null, count: activeLeaveCount };
    }

    /**
     * Rule 3: Monthly Working Days Limit (IST-ONLY)
     * Maximum 5 working days of leave per calendar month
     * Counts only working days (excludes Sundays and policy Saturdays)
     * Includes PENDING + APPROVED leave days
     */
    static async checkMonthlyWorkingDaysLimit(employee, leaveDates, leaveType, holidays) {
        const errors = [];
        const warnings = [];
        
        // Parse first leave date as IST
        const firstLeaveDate = parseISTDate(leaveDates[0]);
        if (!firstLeaveDate) {
            errors.push('Invalid leave date provided.');
            return { blocked: true, errors, warnings, rule: 'INVALID_DATE' };
        }
        
        // Get month and year in IST
        const parts = getDatePartsIST(firstLeaveDate);
        if (!parts) {
            errors.push('Unable to determine month for leave date.');
            return { blocked: true, errors, warnings, rule: 'INVALID_DATE' };
        }
        
        const year = parts.year;
        const month = parts.month; // 1-12
        
        // Calculate month start and end in IST
        const monthStartStr = `${year}-${String(month).padStart(2, '0')}-01`;
        const monthStart = parseISTDate(monthStartStr);
        const lastDay = new Date(year, month, 0).getDate();
        const monthEndStr = `${year}-${String(month).padStart(2, '0')}-${String(lastDay).padStart(2, '0')}`;
        const monthEnd = parseISTDate(monthEndStr);
        if (monthEnd) {
            monthEnd.setHours(23, 59, 59, 999);
        }
        
        if (!monthStart || !monthEnd) {
            errors.push('Unable to calculate month boundaries.');
            return { blocked: true, errors, warnings, rule: 'INVALID_DATE' };
        }
        
        // Get all holidays in this month (IST-aware query)
        const monthHolidays = await Holiday.find({
            date: {
                $gte: monthStart,
                $lte: monthEnd
            }
        });
        
        // Calculate working days by iterating through month in IST
        // Helper function to check if a date is a working day
        const isWorkingDay = (date) => {
            // Parse date as IST
            const dateIST = parseISTDate(date);
            if (!dateIST) return false;
            
            // Check Sunday
            if (this.isSunday(dateIST)) return false;
            
            // Check Saturday (policy-based)
            const parts = getDatePartsIST(dateIST);
            if (!parts) return false;
            const istDate = parseISTDate(`${parts.year}-${String(parts.month).padStart(2, '0')}-${String(parts.day).padStart(2, '0')}`);
            if (!istDate) return false;
            
            if (istDate.getDay() === 6) {
                // It's Saturday, check if it's OFF based on policy
                const saturdayPolicy = employee.alternateSaturdayPolicy || 'All Saturdays Working';
                if (this.isOffSaturday(istDate, saturdayPolicy)) {
                    return false;
                }
            }
            
            // Check holiday
            if (this.isHoliday(dateIST, monthHolidays)) return false;
            
            // It's a working day
            return true;
        };
        
        // Iterate through all dates in month in IST
        // Use month parts to iterate properly
        const monthDays = [];
        for (let day = 1; day <= lastDay; day++) {
            const dayStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            const dayDate = parseISTDate(dayStr);
            if (dayDate) {
                monthDays.push(dayDate);
            }
        }
        
        // Get all PENDING + APPROVED leaves in this month
        const activeLeaves = await LeaveRequest.find({
            employee: employee._id,
            status: { $in: ['Pending', 'Approved'] }, // Count PENDING + APPROVED
            leaveDates: {
                $elemMatch: {
                    $gte: monthStart,
                    $lte: monthEnd
                }
            }
        });
        
        // Calculate total working leave days from existing active leaves
        let totalActiveWorkingLeaveDays = 0;
        for (const leave of activeLeaves) {
            for (const leaveDate of leave.leaveDates) {
                // Parse as IST date string for comparison
                const leaveDateStr = formatDateIST(parseISTDate(leaveDate));
                if (!leaveDateStr) continue;
                
                // Check if date is within month range using string comparison (IST-normalized)
                const monthStartStr = formatDateIST(monthStart);
                const monthEndStr = formatDateIST(monthEnd);
                if (!monthStartStr || !monthEndStr) continue;
                if (leaveDateStr < monthStartStr || leaveDateStr > monthEndStr) continue;
                
                // Check if it's a working day
                const leaveDateIST = parseISTDate(leaveDate);
                if (!leaveDateIST) continue;
                if (isWorkingDay(leaveDateIST)) {
                    const dayMultiplier = leave.leaveType === 'Full Day' ? 1 : 0.5;
                    totalActiveWorkingLeaveDays += dayMultiplier;
                }
            }
        }
        
        // Calculate working leave days from current request
        const dayMultiplier = leaveType === 'Full Day' ? 1 : 0.5;
        let currentRequestWorkingDays = 0;
        for (const leaveDate of leaveDates) {
            const leaveDateIST = parseISTDate(leaveDate);
            if (!leaveDateIST) continue;
            
            // Check if date is within month range
            const leaveDateStr = formatDateIST(leaveDateIST);
            const monthStartStr = formatDateIST(monthStart);
            const monthEndStr = formatDateIST(monthEnd);
            if (!leaveDateStr || !monthStartStr || !monthEndStr) continue;
            if (leaveDateStr < monthStartStr || leaveDateStr > monthEndStr) continue;
            
            // Check if it's a working day
            if (isWorkingDay(leaveDateIST)) {
                currentRequestWorkingDays += dayMultiplier;
            }
        }
        
        const totalWorkingLeaveDays = totalActiveWorkingLeaveDays + currentRequestWorkingDays;
        const maxWorkingDaysPerMonth = 5;
        
        if (totalWorkingLeaveDays > maxWorkingDaysPerMonth) {
            errors.push(`You cannot exceed ${maxWorkingDaysPerMonth} working days of leave per month. You have ${totalActiveWorkingLeaveDays.toFixed(1)} working day(s) from existing requests, and this request adds ${currentRequestWorkingDays.toFixed(1)} working day(s), totaling ${totalWorkingLeaveDays.toFixed(1)} working day(s).`);
            return { 
                blocked: true, 
                errors, 
                warnings, 
                rule: 'MONTHLY_WORKING_DAYS_LIMIT',
                totalWorkingLeaveDays: totalWorkingLeaveDays,
                existingWorkingDays: totalActiveWorkingLeaveDays,
                requestedWorkingDays: currentRequestWorkingDays,
                maxAllowed: maxWorkingDaysPerMonth
            };
        }
        
        // Warning at 4 working days
        if (totalWorkingLeaveDays >= 4) {
            warnings.push(`You have ${totalWorkingLeaveDays.toFixed(1)} working day(s) of leave this month. Maximum ${maxWorkingDaysPerMonth} working days allowed.`);
        }
        
        return { 
            blocked: false, 
            errors, 
            warnings, 
            rule: null,
            totalWorkingLeaveDays: totalWorkingLeaveDays,
            existingWorkingDays: totalActiveWorkingLeaveDays,
            requestedWorkingDays: currentRequestWorkingDays,
            maxAllowed: maxWorkingDaysPerMonth
        };
    }

    /**
     * Main anti-exploitation validation function (IST-ONLY)
     * Runs all three rules and returns consolidated result
     * @param {Object} employee - Employee object
     * @param {Array} leaveDates - Array of leave dates
     * @param {String} leaveType - Leave type (Full Day, Half Day - First Half, Half Day - Second Half)
     * @param {Array} holidays - Array of holiday objects (optional)
     * @param {String} requestType - Leave request type (Planned, Casual, Sick, Loss of Pay, etc.)
     */
    static async validateAntiExploitation(employee, leaveDates, leaveType = 'Full Day', holidays = null, requestType = null) {
        const allErrors = [];
        const allWarnings = [];
        const blockedRules = [];
        const validationDetails = {};
        
        // Rule 1: Friday/Monday blocking (STRICT - applies to ALL leave types)
        const fridayMondayCheck = this.checkFridayMondayBlocking(leaveDates);
        if (fridayMondayCheck.blocked) {
            allErrors.push(...fridayMondayCheck.errors);
            blockedRules.push(fridayMondayCheck.rule);
            validationDetails.fridayMondayBlocking = {
                blocked: true,
                rule: fridayMondayCheck.rule
            };
        }
        
        // Rule 2: Monthly frequency cap (PENDING + APPROVED)
        const frequencyCheck = await this.checkMonthlyLeaveFrequency(employee._id, leaveDates);
        if (frequencyCheck.blocked) {
            allErrors.push(...frequencyCheck.errors);
            blockedRules.push(frequencyCheck.rule);
            validationDetails.monthlyFrequency = {
                blocked: true,
                rule: frequencyCheck.rule,
                count: frequencyCheck.count
            };
        } else {
            validationDetails.monthlyFrequency = {
                blocked: false,
                count: frequencyCheck.count
            };
        }
        allWarnings.push(...frequencyCheck.warnings);
        
        // Rule 3: Monthly working days limit (5 working days max)
        const workingDaysCheck = await this.checkMonthlyWorkingDaysLimit(employee, leaveDates, leaveType, holidays);
        if (workingDaysCheck.blocked) {
            allErrors.push(...workingDaysCheck.errors);
            blockedRules.push(workingDaysCheck.rule);
            validationDetails.monthlyWorkingDaysLimit = {
                blocked: true,
                rule: workingDaysCheck.rule,
                totalWorkingLeaveDays: workingDaysCheck.totalWorkingLeaveDays,
                existingWorkingDays: workingDaysCheck.existingWorkingDays,
                requestedWorkingDays: workingDaysCheck.requestedWorkingDays,
                maxAllowed: workingDaysCheck.maxAllowed
            };
        } else {
            validationDetails.monthlyWorkingDaysLimit = {
                blocked: false,
                totalWorkingLeaveDays: workingDaysCheck.totalWorkingLeaveDays,
                existingWorkingDays: workingDaysCheck.existingWorkingDays,
                requestedWorkingDays: workingDaysCheck.requestedWorkingDays,
                maxAllowed: workingDaysCheck.maxAllowed
            };
        }
        allWarnings.push(...workingDaysCheck.warnings);
        
        const isBlocked = blockedRules.length > 0;
        
        // Log blocked leave attempts
        if (isBlocked) {
            await this.logBlockedLeave(employee, leaveDates, blockedRules, validationDetails, requestType, frequencyCheck.count);
        }
        
        return {
            blocked: isBlocked,
            errors: allErrors,
            warnings: allWarnings,
            blockedRules,
            validationDetails
        };
    }

    /**
     * Log blocked leave attempts for audit (IST-ONLY)
     * @param {Object} employee - Employee object
     * @param {Array} leaveDates - Array of leave dates
     * @param {Array} blockedRules - Array of rules that blocked the leave
     * @param {Object} validationDetails - Validation details object
     * @param {String} requestType - Leave request type
     * @param {Number} activeLeaveCount - Number of active leaves at apply time
     */
    static async logBlockedLeave(employee, leaveDates, blockedRules, validationDetails, requestType = null, activeLeaveCount = null) {
        try {
            // Parse first date as IST
            const firstLeaveDate = parseISTDate(leaveDates[0]);
            if (!firstLeaveDate) return;
            
            const parts = getDatePartsIST(firstLeaveDate);
            if (!parts) return;
            
            // Determine which rule triggered the block
            const policyRuleTriggered = blockedRules.length > 0 ? blockedRules[0] : null;
            
            await logAction({
                action: 'LEAVE_BLOCKED_ANTI_EXPLOITATION',
                userId: employee._id.toString(),
                details: {
                    employeeCode: employee.employeeCode,
                    employeeName: employee.fullName,
                    leaveType: requestType || 'Unknown',
                    month: parts.month,
                    year: parts.year,
                    leaveDates: leaveDates.map(d => formatDateIST(parseISTDate(d))).filter(d => d !== null),
                    blockedRules: blockedRules,
                    policyRuleTriggered: policyRuleTriggered,
                    activeLeaveCountAtApplyTime: activeLeaveCount,
                    validationDetails: validationDetails,
                    timestamp: new Date().toISOString()
                }
            });
        } catch (error) {
            console.error('Error logging blocked leave:', error);
        }
    }
}

module.exports = AntiExploitationLeaveService;

